#!/usr/bin/env python3
"""
DaVinci Resolve Top 5 auto-edit (best-effort Resolve API automation).

Reads a manifest JSON generated by pipeline.py (or video_pipeline_lib.py) and attempts to:
- open Resolve API
- create/load project + timeline
- import voiceover, images, music
- place assets in pacing order
- add basic transitions when API supports it
- start render with YouTube-friendly preset

Usage:
  python3 tools/davinci_top5_autocut.py \
    --manifest "<PROJECT_ROOT>/content/pipeline_runs/<run>/davinci_manifest.json"
"""

from __future__ import annotations

import argparse
import json
import os
import subprocess
import sys
import time
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from lib.common import now_iso


def load_manifest(path: Path) -> Dict:
    return json.loads(path.read_text(encoding="utf-8"))


def ffprobe_duration_seconds(path: Path) -> float:
    if not path.exists():
        return 0.0
    cmd = [
        "ffprobe",
        "-v",
        "error",
        "-show_entries",
        "format=duration",
        "-of",
        "default=noprint_wrappers=1:nokey=1",
        str(path),
    ]
    p = subprocess.run(cmd, capture_output=True, text=True, check=False)
    raw = (p.stdout or "").strip()
    try:
        return float(raw)
    except ValueError:
        return 0.0


def resolve_module():
    api_root = "/Library/Application Support/Blackmagic Design/DaVinci Resolve/Developer/Scripting"
    module_dir = f"{api_root}/Modules"
    os.environ.setdefault("RESOLVE_SCRIPT_API", api_root)
    os.environ.setdefault("PYTHONPATH", module_dir)
    if module_dir not in sys.path:
        sys.path.append(module_dir)
    import DaVinciResolveScript  # type: ignore

    return DaVinciResolveScript


def connect_resolve(timeout_sec: int = 90) -> Any:
    drv = resolve_module()
    deadline = time.time() + timeout_sec
    while time.time() < deadline:
        app = drv.scriptapp("Resolve")
        if app:
            return app
        time.sleep(2)
    raise RuntimeError("Could not connect to DaVinci Resolve API. Keep Resolve open and retry.")


def get_project_manager(resolve: Any) -> Any:
    pm = resolve.GetProjectManager()
    if not pm:
        raise RuntimeError("Resolve project manager unavailable.")
    if hasattr(pm, "GotoRootFolder"):
        try:
            pm.GotoRootFolder()
        except Exception:  # noqa: BLE001
            pass
    return pm


def ensure_project(pm: Any, project_name: str) -> Any:
    proj = pm.LoadProject(project_name)
    if not proj:
        proj = pm.CreateProject(project_name)
    if not proj:
        raise RuntimeError(f"Cannot create/load project: {project_name}")
    return proj


def ensure_timeline(project: Any, timeline_name: str) -> Any:
    mp = project.GetMediaPool()
    if not mp:
        raise RuntimeError("Media pool not available.")
    timeline = None
    if hasattr(project, "GetTimelineCount"):
        count = int(project.GetTimelineCount() or 0)
        for idx in range(1, count + 1):
            t = project.GetTimelineByIndex(idx)
            if t and t.GetName() == timeline_name:
                timeline = t
                break
    if not timeline and hasattr(mp, "CreateEmptyTimeline"):
        timeline = mp.CreateEmptyTimeline(timeline_name)
    if not timeline:
        raise RuntimeError(f"Cannot create/find timeline: {timeline_name}")
    if hasattr(project, "SetCurrentTimeline"):
        project.SetCurrentTimeline(timeline)
    return timeline


def import_media(media_pool: Any, paths: List[str]) -> List[Any]:
    valid = [p for p in paths if p and Path(p).exists()]
    if not valid:
        return []
    items = media_pool.ImportMedia(valid)
    return list(items or [])


def append_clip_info(
    media_pool: Any,
    item: Any,
    record_frame: int,
    start_frame: int,
    end_frame: int,
    track_index: int,
    media_type: int,
) -> bool:
    # mediaType: 1 video, 2 audio
    info = {
        "mediaPoolItem": item,
        "startFrame": int(start_frame),
        "endFrame": int(end_frame),
        "recordFrame": int(record_frame),
        "trackIndex": int(track_index),
        "mediaType": int(media_type),
    }
    try:
        out = media_pool.AppendToTimeline([info])
        return bool(out)
    except Exception:  # noqa: BLE001
        return False


def try_add_cross_dissolve(timeline: Any, report_notes: List[str]) -> None:
    # Resolve scripting APIs differ by version; we probe safely.
    possible_methods = [
        "AddTransition",
        "InsertTransition",
    ]
    found = [m for m in possible_methods if hasattr(timeline, m)]
    if found:
        report_notes.append(
            f"Transition methods detected ({', '.join(found)}). Integrate per-version method signature if needed."
        )
    else:
        report_notes.append(
            "No direct transition method found in API probe. Use manual one-click apply-to-all transitions in Edit page."
        )


def apply_render(project: Any, resolve: Any, render_cfg: Dict, report_notes: List[str]) -> Tuple[bool, List[str]]:
    target_dir = Path(render_cfg.get("target_dir", "")).expanduser()
    target_dir.mkdir(parents=True, exist_ok=True)
    custom_name = render_cfg.get("custom_name", "top5_export")
    presets = render_cfg.get("preset_candidates", [])

    try:
        if hasattr(resolve, "OpenPage"):
            resolve.OpenPage("deliver")
    except Exception:  # noqa: BLE001
        pass

    loaded = False
    if hasattr(project, "LoadRenderPreset"):
        for preset in presets:
            try:
                if project.LoadRenderPreset(preset):
                    loaded = True
                    report_notes.append(f"Loaded render preset: {preset}")
                    break
            except Exception:  # noqa: BLE001
                continue
    if not loaded:
        report_notes.append("No render preset loaded from candidates. Continuing with manual settings.")

    if hasattr(project, "SetRenderSettings"):
        try:
            project.SetRenderSettings(
                {
                    "SelectAllFrames": 1,
                    "TargetDir": str(target_dir),
                    "CustomName": custom_name,
                }
            )
        except Exception as exc:  # noqa: BLE001
            report_notes.append(f"SetRenderSettings failed: {exc}")

    add_job_ok = False
    if hasattr(project, "AddRenderJob"):
        try:
            add_job_ok = bool(project.AddRenderJob())
        except Exception:  # noqa: BLE001
            add_job_ok = False

    start_ok = False
    if hasattr(project, "StartRendering"):
        try:
            start_ok = bool(project.StartRendering())
        except Exception:  # noqa: BLE001
            start_ok = False

    return add_job_ok and start_ok, [str(x) for x in target_dir.glob(f"{custom_name}*")]


def run(manifest_path: Path, dry_run: bool = False) -> Dict:
    manifest = load_manifest(manifest_path)
    notes: List[str] = []
    report: Dict = {
        "timestamp": now_iso(),
        "manifest": str(manifest_path),
        "ok": False,
        "dry_run": dry_run,
        "steps": {},
        "notes": notes,
        "render_files": [],
    }

    if dry_run:
        report["ok"] = True
        report["steps"]["dry_run"] = True
        notes.append("Dry run completed. No Resolve API actions executed.")
        return report

    resolve = connect_resolve()
    report["steps"]["connect_resolve"] = True

    pm = get_project_manager(resolve)
    report["steps"]["project_manager"] = True

    project = ensure_project(pm, manifest["project_name"])
    report["steps"]["project_ready"] = True

    timeline = ensure_timeline(project, manifest["timeline_name"])
    report["steps"]["timeline_ready"] = True

    media_pool = project.GetMediaPool()
    if not media_pool:
        raise RuntimeError("Media pool unavailable in project.")

    voice_path = Path(manifest.get("voiceover_path", ""))
    music_path = Path(manifest.get("music_path", ""))
    image_paths = [x.get("path", "") for x in manifest.get("image_assets", [])]
    import_paths = [str(voice_path), str(music_path)] + image_paths

    imported = import_media(media_pool, import_paths)
    report["steps"]["import_media"] = bool(imported)
    item_by_path = {str(Path(i.GetClipProperty("File Path") or "")): i for i in imported if i}

    fps = int(manifest.get("fps", 30) or 30)
    total_frames = 0
    if voice_path.exists():
        total_frames = int(ffprobe_duration_seconds(voice_path) * fps)
    if total_frames <= 0:
        total_frames = fps * 8 * 60
        notes.append("Voiceover duration not found. Using fallback 8-minute timeline.")

    # Place voiceover on audio track 1
    voice_item = item_by_path.get(str(voice_path))
    if voice_item:
        ok_voice = append_clip_info(
            media_pool=media_pool,
            item=voice_item,
            record_frame=0,
            start_frame=0,
            end_frame=total_frames,
            track_index=1,
            media_type=2,
        )
        report["steps"]["place_voiceover"] = ok_voice
    else:
        report["steps"]["place_voiceover"] = False
        notes.append("Voiceover item not imported. Verify manifest voiceover_path.")

    # Place product images on video track 1 with equal pacing.
    images = [Path(p) for p in image_paths if p]
    valid_images = [p for p in images if p.exists()]
    report["steps"]["valid_images"] = len(valid_images)
    if valid_images:
        frames_per_image = max(45, int(total_frames / len(valid_images)))
        cursor = 0
        place_ok = True
        for img_path in valid_images:
            item = item_by_path.get(str(img_path))
            if not item:
                continue
            ok = append_clip_info(
                media_pool=media_pool,
                item=item,
                record_frame=cursor,
                start_frame=0,
                end_frame=frames_per_image,
                track_index=1,
                media_type=1,
            )
            place_ok = place_ok and ok
            cursor += frames_per_image
        report["steps"]["place_images"] = place_ok
    else:
        report["steps"]["place_images"] = False
        notes.append("No valid image assets found. Add generated Dzine images to manifest paths.")

    # Place music on audio track 2
    music_item = item_by_path.get(str(music_path))
    if music_item:
        ok_music = append_clip_info(
            media_pool=media_pool,
            item=music_item,
            record_frame=0,
            start_frame=0,
            end_frame=total_frames,
            track_index=2,
            media_type=2,
        )
        report["steps"]["place_music"] = ok_music
    else:
        report["steps"]["place_music"] = False
        notes.append("Music item not imported. Add background track path in manifest.")

    # Transitions (probe only; API is version-dependent).
    try_add_cross_dissolve(timeline, notes)
    report["steps"]["transitions_probe"] = True

    # Caption note: full auto captions are not universally exposed in Resolve scripting API.
    if manifest.get("caption_srt_path"):
        notes.append(
            "Caption path provided. If API import is unavailable in your Resolve version, import SRT manually in Edit page."
        )

    render_ok, render_files = apply_render(project, resolve, manifest.get("render", {}), notes)
    report["steps"]["render_started"] = render_ok
    report["render_files"] = render_files
    report["ok"] = True
    return report


def main() -> int:
    parser = argparse.ArgumentParser(description="DaVinci Top 5 auto-edit runner.")
    parser.add_argument("--manifest", required=True, help="Path to davinci_manifest.json")
    parser.add_argument("--dry-run", action="store_true", help="Validate manifest only")
    parser.add_argument("--report", default="", help="Optional report output path")
    args = parser.parse_args()

    manifest = Path(args.manifest).expanduser()
    if not manifest.exists():
        print(json.dumps({"ok": False, "error": f"Manifest not found: {manifest}"}, indent=2))
        return 2

    try:
        report = run(manifest_path=manifest, dry_run=args.dry_run)
    except Exception as exc:  # noqa: BLE001
        report = {"ok": False, "error": str(exc), "timestamp": now_iso(), "manifest": str(manifest)}

    report_path = Path(args.report).expanduser() if args.report else manifest.with_name("davinci_run_report.json")
    _tmp = report_path.with_suffix(".tmp")
    _payload = json.dumps(report, indent=2).encode("utf-8")
    _fd = os.open(str(_tmp), os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o644)
    try:
        os.write(_fd, _payload)
        os.fsync(_fd)
    finally:
        os.close(_fd)
    os.replace(str(_tmp), str(report_path))
    print(json.dumps(report, indent=2))
    return 0 if report.get("ok") else 1


if __name__ == "__main__":
    raise SystemExit(main())

